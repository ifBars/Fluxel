//! Tauri commands for the profiling subsystem.
//!
//! Exposes commands to the frontend:
//! - `profiler_set_enabled` - Enable/disable span collection
//! - `profiler_get_status` - Get profiler status
//! - `profiler_get_recent_spans` - Get recent span summaries
//! - `profiler_get_attribution` - Get attribution report for a span tree
//! - `profiler_clear` - Clear all stored spans
//! - `profiler_start_session` - Start a named profiling session
//! - `profiler_end_session` - End a session and get report
//! - `profiler_record_frontend_span` - Record a span from the frontend
//! - `profiler_export` - Export spans as JSON or Chrome Trace format

use serde::{Deserialize, Serialize};
use tauri::State;

use crate::profiling::attribution::{AttributionEngine, AttributionReport};
use crate::profiling::buffer::{SpanCategory, SpanId, SpanSummary};
use crate::profiling::sessions::SessionReport;
use crate::profiling::FluxelProfiler;

/// Profiler status response.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProfilerStatus {
    /// Whether profiling is enabled.
    pub enabled: bool,
    /// Number of spans currently stored.
    pub span_count: usize,
    /// Maximum buffer capacity.
    pub buffer_capacity: usize,
    /// Active session ID, if any.
    pub active_session_id: Option<String>,
}

/// Frontend span input for recording.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FrontendSpanInput {
    /// Unique span ID generated by the frontend.
    pub id: String,
    /// Span name (e.g., "MyComponent:render").
    pub name: String,
    /// Category of the span.
    pub category: String,
    /// Duration in milliseconds.
    pub duration_ms: f64,
    /// Optional parent span ID.
    pub parent_id: Option<String>,
    /// Optional metadata as key-value pairs.
    pub metadata: Option<Vec<(String, String)>>,
}

/// Export format for profiling data.
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ExportFormat {
    Json,
    ChromeTrace,
}

// =============================================================================
// Basic Commands
// =============================================================================

/// Enable or disable span collection.
#[tauri::command]
pub fn profiler_set_enabled(state: State<'_, FluxelProfiler>, enabled: bool) {
    state.set_enabled(enabled);
    println!(
        "[Profiling] Collection {}",
        if enabled { "enabled" } else { "disabled" }
    );
}

/// Get the current profiler status.
#[tauri::command]
pub fn profiler_get_status(state: State<'_, FluxelProfiler>) -> ProfilerStatus {
    ProfilerStatus {
        enabled: state.is_enabled(),
        span_count: state.span_count(),
        buffer_capacity: state.capacity(),
        active_session_id: state.active_session_id(),
    }
}

/// Get the most recent spans.
///
/// # Arguments
/// * `limit` - Maximum number of spans to return (default: 100)
#[tauri::command]
pub fn profiler_get_recent_spans(
    state: State<'_, FluxelProfiler>,
    limit: Option<usize>,
) -> Vec<SpanSummary> {
    state.recent_spans(limit.unwrap_or(100))
}

/// Get an attribution report for a span tree.
///
/// # Arguments
/// * `root_span_id` - The ID of the root span to analyze
#[tauri::command]
pub fn profiler_get_attribution(
    state: State<'_, FluxelProfiler>,
    root_span_id: String,
) -> Result<AttributionReport, String> {
    // Parse span ID
    let root_id: SpanId = root_span_id
        .parse()
        .map_err(|_| format!("Invalid span ID: {}", root_span_id))?;

    // Get span tree
    let tree = state.get_span_tree(root_id);

    if tree.is_empty() {
        return Err(format!("Span not found: {}", root_span_id));
    }

    // Find root span in tree
    let root = tree
        .iter()
        .find(|s| s.id == root_span_id)
        .cloned()
        .ok_or_else(|| format!("Root span not found in tree: {}", root_span_id))?;

    // Generate attribution report
    let report = AttributionEngine::analyze(root, &tree);

    Ok(report)
}

/// Clear all stored spans (useful for resetting between profiling sessions).
#[tauri::command]
pub fn profiler_clear(state: State<'_, FluxelProfiler>) {
    state.clear();
    println!("[Profiling] Buffer cleared");
}

// =============================================================================
// Session Commands
// =============================================================================

/// Start a named profiling session.
///
/// # Arguments
/// * `name` - Human-readable session name
///
/// # Returns
/// The session ID to use when ending the session
#[tauri::command]
pub fn profiler_start_session(state: State<'_, FluxelProfiler>, name: String) -> String {
    let session_id = state.start_session(name.clone());
    println!(
        "[Profiling] Started session '{}' (ID: {})",
        name, session_id
    );
    session_id
}

/// End a profiling session and get the report.
///
/// # Arguments
/// * `session_id` - The session ID returned from `profiler_start_session`
#[tauri::command]
pub fn profiler_end_session(
    state: State<'_, FluxelProfiler>,
    session_id: String,
) -> Result<SessionReport, String> {
    state
        .end_session(&session_id)
        .ok_or_else(|| format!("Session not found or already ended: {}", session_id))
}

// =============================================================================
// Frontend Span Recording
// =============================================================================

/// Record a span from the frontend.
///
/// This allows React/TypeScript code to record profiling data that will be
/// merged with backend spans for unified analysis.
#[tauri::command]
pub fn profiler_record_frontend_span(state: State<'_, FluxelProfiler>, span: FrontendSpanInput) {
    // Parse category
    let category = match span.category.as_str() {
        "frontend_render" => SpanCategory::FrontendRender,
        "frontend_interaction" => SpanCategory::FrontendInteraction,
        "frontend_network" => SpanCategory::FrontendNetwork,
        "tauri_command" => SpanCategory::TauriCommand,
        "file_io" => SpanCategory::FileIo,
        "git_operation" => SpanCategory::GitOperation,
        "lsp_request" => SpanCategory::LspRequest,
        "search" => SpanCategory::Search,
        "workspace" => SpanCategory::Workspace,
        _ => SpanCategory::Other,
    };

    // Parse the frontend-provided span ID (preserve it for parent-child relationships)
    let span_id: SpanId = span.id.parse().unwrap_or(0);

    state.record_frontend_span(
        span_id,
        span.name,
        category,
        span.duration_ms,
        span.parent_id,
        span.metadata.unwrap_or_default(),
    );
}

// =============================================================================
// Export Commands
// =============================================================================

/// Export profiling data in the specified format.
///
/// # Arguments
/// * `format` - Export format: "json" or "chrome_trace"
/// * `session_name` - Name to include in the export (for Chrome Trace)
/// * `limit` - Maximum number of spans to export (default: 10000)
#[tauri::command]
pub fn profiler_export(
    state: State<'_, FluxelProfiler>,
    format: ExportFormat,
    session_name: Option<String>,
    limit: Option<usize>,
) -> String {
    match format {
        ExportFormat::Json => state.export_json(limit),
        ExportFormat::ChromeTrace => {
            state.export_chrome_trace(&session_name.unwrap_or_else(|| "fluxel".to_string()), limit)
        }
    }
}
